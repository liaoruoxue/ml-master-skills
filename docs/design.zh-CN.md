这份设计文档旨在指导开发团队将现有的 `planning-with-files` 仓库重构为 **ML-Master 2.0** 的完整工程实现。

---

# ML-Master 2.0 实现需求设计文档
**目标项目**：改造 `planning-with-files` 仓库
**核心理论**：Hierarchical Cognitive Caching (HCC) 架构
**设计目标**：实现超长视界（Ultra-Long-Horizon）的自主机器学习工程能力

---

## 1. 核心架构重构：HCC 分层存储设计

原仓库的文件结构是扁平的，ML-Master 2.0 要求将存储严格划分为三个认知层级。需对文件定义和生命周期进行重新设计。

### 1.1 L1 层：演进体验 (Evolving Experience)
*   **对应文件**：`execution_trace.md` (原 `progress.md` 的改造)
*   **功能定义**：作为 Agent 的“工作记忆 (RAM)”。
*   **存储内容**：
    *   当前正在执行的代码片段（Code Patches）。
    *   原始终端输出（Terminal Outputs）、错误堆栈。
    *   单步调试的临时观察。
*   **生命周期**：**极短**。仅在当前“探索阶段”内保留。一旦阶段结束触发“Context Promotion”，此文件必须被**清空**或归档。

### 1.2 L2 层：提炼知识 (Refined Knowledge)
*   **对应文件**：`findings.md` (增强版)
*   **功能定义**：作为 Agent 的“中期战略记忆”。
*   **存储内容**：
    *   **关键判断 (Judgments)**：例如“特征 A 导致了过拟合”。
    *   **实验洞察 (Insights)**：例如“学习率 1e-4 比 1e-3 更稳定”。
    *   **阶段性总结**：从 L1 中提炼出的高价值信息，去除噪音。
*   **生命周期**：**任务级持久化**。在整个任务周期内保留，用于跨越多次 Context Clear。

### 1.3 L2 层：战略状态 (Strategic State)
*   **对应文件**：`task_plan.md` (结构化改造)
*   **功能定义**：防止“目标漂移 (Goal Drift)”。
*   **存储内容**：
    *   **分层计划树**：探索方向 (Directions) -> 具体实施 (Implementations)。
    *   **状态追踪**：待办 / 进行中 / 已完成 / 已放弃。
*   **生命周期**：**任务级持久化**。随任务进展动态更新。

### 1.4 L3 层：先验智慧 (Prior Wisdom)
*   **对应文件**：新增 `wisdom/` 目录或 `global_wisdom.md`
*   **功能定义**：作为 Agent 的“长期记忆 (Long-term Memory)”。
*   **存储内容**：
    *   跨任务通用的代码模板（如鲁棒的 CV 验证框架）。
    *   常见错误的解决方案库。
    *   最佳实践清单。
*   **生命周期**：**永久**。跨任务存在，只读（除非任务结束时触发 L3 更新）。

---

## 2. 核心机制设计：上下文迁移 (Context Migration)

这是 ML-Master 2.0 的引擎，需要通过脚本或 Prompt 逻辑实现数据的自动化流转。

### 2.1 机制一：上下文预取 (Context Prefetching)
*   **触发时机**：任务初始化阶段（`/plan` 命令执行时）。
*   **逻辑需求**：
    1.  分析用户输入的任务描述。
    2.  从 L3 (`wisdom/`) 中检索最相关的知识片段（例如：如果是图像分类任务，提取 CNN 相关智慧；如果是表格数据，提取 XGBoost 相关智慧）。
    3.  将提取的智慧注入到 `task_plan.md` 的初始部分或 Context 中，作为“热启动”信息。

### 2.2 机制二：上下文提升 (Context Promotion) - 阶段级
*   **触发时机**：当 `task_plan.md` 中的一个“子阶段”被标记为完成时。
*   **逻辑需求**：
    1.  **读取** L1 (`execution_trace.md`) 的全部内容。
    2.  **执行认知压缩**：调用 LLM 总结该阶段的“执行摘要”和“战略洞察”。
    3.  **写入** L2 (`findings.md`)。
    4.  **清空** L1 (`execution_trace.md`)。
    *   *目的*：释放上下文窗口，将“噪音”转化为“信号”。

### 2.3 机制三：上下文命中 (Context Hit)
*   **触发时机**：Agent 准备生成新代码或回答问题时。
*   **逻辑需求**：
    1.  优先检查 L1：如果问题涉及刚才的报错，直接从 L1 获取。
    2.  回退检查 L2：如果问题涉及之前的实验结论，从 L2 获取。
    *   *实现方式*：通过系统提示词（System Prompt）强制 Agent 在行动前先查阅这两个文件。

---

## 3. 交互流程与指令设计 (SKILL.md 改造)

需要重写 `SKILL.md`，将上述逻辑转化为 Agent 必须遵守的“宪法”。

### 3.1 系统提示词 (System Prompt) 核心规则
1.  **双重读写规则**：
    *   对于**执行细节**（代码运行、报错），必须且只能写入 L1。
    *   对于**结论**（什么有效、什么无效），必须且只能写入 L2。
2.  **2-Action Rule (两步一记)**：
    *   强制 Agent 每执行 2 个工具调用（如 `RunCommand`, `EditFile`），必须更新一次 L1 文件。
3.  **禁止上下文堆积**：
    *   明确禁止 Agent 依赖对话历史来记忆之前的错误，必须依赖文件记录。

### 3.2 新增命令设计
*   **`/promote`**：手动触发阶段性总结。强制执行 L1 -> L2 的转化并清空 L1。
*   **`/recover`**：用于 `/clear` 之后的恢复。强制 Agent 仅读取 L2 (`task_plan.md`, `findings.md`) 来重建认知状态，忽略之前的对话历史。

---

## 4. 模板与脚本需求

### 4.1 模板文件 (`templates/`)
*   **`task_plan.md`**：需预设分层结构（Phase / Sub-task / Status / Outcome）。
*   **`findings.md`**：需预设结构化板块（Key Insights / Validated Hypotheses / Failed Attempts）。
*   **`execution_trace.md`**：需包含时间戳、操作类型、输出摘要的占位符。

### 4.2 自动化脚本 (`scripts/`)
*   **初始化脚本**：在项目启动时，自动创建上述三个文件，并根据任务类型从 L3 复制模板。
*   **清理脚本**：提供一个工具函数，允许 Agent 一键清空 `execution_trace.md`（在 Promotion 完成后调用）。

---

## 5. 验收标准 (Success Metrics)

改造完成后的系统应满足以下标准，以证明实现了 ML-Master 2.0：

1.  **持久化验证**：在 Claude Code 中执行 `/clear` 清空上下文后，Agent 能够通过读取文件，在 1 分钟内准确说出：“我们刚才完成了 X 阶段，发现了 Y 结论，下一步计划是 Z”，且**不包含**之前冗余的报错信息。
2.  **信息流转验证**：L1 文件的大小应呈现“锯齿状”（随执行增加，阶段结束归零），而 L2 文件的大小应呈现“阶梯状”（随阶段结束而单调增加）。
3.  **长程推理能力**：Agent 在第 50 轮对话时，仍能引用第 1 轮对话中确立并在 L2 中记录的战略原则，而不会发生“目标漂移”。